<div class="chapter-item">
  <a name="extend扩展"></a>
  <h2 class="chapter-title">Extend扩展</h2>
  <p>
    Extend is a Less pseudo-class(伪类) which merges the selector
    (it is put on) with ones that match what it references.
  </p>
  <pre><code class="language-less">nav ul {
  &amp;:extend(.inline);
  background: blue;
}</code></pre>
  <p>
    上例中，:extend将.inline类的规则应用到nav ul中，
    无论.inline类是定义在哪里的。
    除去extend外，声明块保持原样，因为extend不是样式表规则。
  </p>
  <pre><code class="language-less">nav ul {
  &amp;:extend(.inline);
  background: blue;
}
.inline {
  color: red;
}</code></pre>编译为: <pre><code class="language-css">nav ul {
  background: blue;
}
.inline,
nav ul {
  color: red;
}</code></pre>
  <p>
    注意 nav ul:extend(.inline) 选择器如何编译: 输出前就移除了extend，规则列表中其他部分保持原样。
    如果规则列表中没有定义任何属性，就会直接从编译结果中移除。
    (but the extend still may affect other selectors)
  </p>
  <ol>
    <li>
      <h3>Extend语法</h3>
      <p>
        extend既可以附加在选择器上，也可以放置于规则列表中。
        它看起来像是一个带着选择器参数和可选关键字all的伪类。
      </p>
      <pre><code class="language-less">.a:extend(.b) {}
// 上面的代码和下面的代码编译结果是一样的。
.a {
  &amp;:extend(.b);
}

.c:extend(.d all) {
  // 扩展所有与".d"相关的选择器实例，如：".x.d" or ".d.x"
}
.c:extend(.d) {
  // 只扩展编译结果为".d"的选择器实例。
}</code></pre>可以传递多个用于扩展的选择器参数，用逗号分开: <pre><code class="language-less">.e:extend(.f) {}
.e:extend(.g) {}
// 上面过的代码和下面的代码结果一样。
.e:extend(.f, .g) {}</code></pre>
      <h4>附加到选择器上的extend</h4>
      <p>
        附加到选择器上的extend看起来像传递了选择器参数的一般的伪类一样，
        一个选择器可以包含多个扩展从句，但是所有扩展都必须位于选择器的最后。
      </p>
      <ul>
        <li>Extend after the selector: <code class="language-less">pre:hover:extend(div pre)</code></li>
        <li>选择器和extend从句之间可以有空格: <code class="language-less">pre:hover :extend(div pre)</code></li>
        <li>选择器和extend从句之间可以有空格: <code class="language-less">pre:hover :extend(div pre)</code></li>
        <li>多个extend也是可以的: <code class="language-less">pre:hover:extend(div pre):extend(.bucket tr)</code></li>
        <li>注意这条语法等于 <code class="language-less">pre:hover:extend(div pre, .bucket tr)</code></li>
        <li><code class="language-less">pre:hover:extend(div pre).nth-child(odd)</code>这样的语法是不被允许的，extend必须位于最后</li>
      </ul>
      <p>
        如果一个规则列表中包含了多个选择器，任意一个选择器都可以使用extend。
        any of them can have the extend keyword. Multiple selectors with extend in one ruleset:
      </p>
      <pre><code class="language-less">.big-division,
.big-bag:extend(.bag),
.big-bucket:extend(.bucket) {
  color: red;
}
.bag {
  font-size: 14px;
}
.bucket {
  font-size: 20px;
}</code></pre>编译为: <pre><code class="language-css">.big-division,
.big-bag,
.big-bucket {
  color: red;
}
.bag,
.big-bag {
  font-size: 14px;
}
.bucket,
.big-bucket {
  font-size: 20px;
}</code></pre>
      <h4>规则列表中的Extend</h4>
      <p>
        使用<code class="language-less">&amp:extend(selector)</code>语法，
        可以将extend放置于规则列表中，这是一种简写方式，用于为规则列表的每一个选择器设置extend。
      </p>
      <pre><code class="language-less">pre:hover,
.some-class {
  &amp;:extend(div pre);
}
//这两段规则是一样的。
pre:hover:extend(div pre),
.some-class:extend(div pre) {}</code></pre>
      <h4>扩展嵌套选择器</h4>
      <p>
        extend可以匹配嵌套的选择器:
      </p>
      <pre><code class="language-less">.bucket {
  tr { // nested ruleset with target selector
    color: blue;
  }
}
.some-class:extend(.bucket tr) {} // nested ruleset is recognized</code></pre>编译为:
      <pre><code class="language-css">.bucket tr,
.some-class {
  color: blue;
}</code></pre><strong>本质上，extend查找的是编译好的css而不是less源文件</strong>
      <pre><code class="language-less">.bucket {
  tr &amp; { // nested ruleset with target selector
    color: blue;
  }
}
.some-class:extend(tr .bucket) {} // nested ruleset is recognized</code></pre>
编译为: <pre><code class="language-css">tr .bucket,
.some-class {
  color: blue;
}</code></pre>
      <h4>精确匹配 Extend</h4>
      <p>
        extend默认查找精确匹配的选择器，这与选择器是否有leading是有关系的，
        但是与两个nth-表达式是否表达同一个意思是没关系的，他们必须是一毛一样。
        唯一的例外是属性选择器中的引号，less可以匹配不同的表达。
      </p>
      <pre><code class="language-less">.a.class,
.class.a,
.class > .a {
  color: blue;
}
.test:extend(.class) {} // 这个extend不会匹配上列任何一个选择器。</code></pre>
先导选择器很有毛关系。 选择器*.class和.class是一样的,但是extend不会匹配他们 <pre><code class="language-less">*.class {
  color: blue;
}
.noStar:extend(.class) {} // 不能匹配到*.class选择器</code></pre>编译为: <pre><code class="language-less">*.class {
  color: blue;
}</code></pre>伪类的顺序也很重要。选择器<code class="language-css">link:hover:visited</code>和
<code class="language-less">link:visited:hover</code>匹配到同一个元素，但是extend不能匹配他们:
<pre><code class="language-less">link:hover:visited {
  color: blue;
}
.selector:extend(link:visited:hover) {}</code></pre>编译为: <pre><code class="language-css">link:hover:visited {
  color: blue;
}</code></pre>nth表达式的格式其实无关紧要，1n+3和n+3是一样的，但是extend不能匹配他们:
<pre><code class="language-less">:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}</code></pre>编译为: <pre><code class="language-css">:nth-child(1n+3) {
  color: blue;
}</code></pre>属性的引号类型无关紧要，下列所有选择器都是一样的: <pre><code class="language-less">[title=identifier] {
  color: blue;
}
[title='identifier'] {
  color: blue;
}
[title="identifier"] {
  color: blue;
}
.noQuote:extend([title=identifier]) {}
.singleQuote:extend([title='identifier']) {}
.doubleQuote:extend([title="identifier"]) {}</code></pre>编译为:
<pre><code class="language-css">[title=identifier],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title='identifier'],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title="identifier"],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}</code></pre>
    </li>
    <li>
      <h3>Extend "all"</h3>
      <p>
        当在参数最后指定all关键字的时候，less会去匹配任何带有参数选择器作为一部分或全部的选择器。
        选择器将被替换到（选择器参数所在的选择器）中的选择器参数用以生成新的选择器。
      </p>
      <pre><code class="language-less">.a.b.test,
.test.c {
  color: orange;
}
.test {
  &amp;:hover {
    color: green;
  }
}

.replacement:extend(.test all) {}</code></pre>编译为: <pre><code class="language-css">.a.b.test,
.test.c,
.a.b.replacement,
.replacement.c {
  color: orange;
}
.test:hover,
.replacement:hover {
  color: green;
}</code></pre>本质上可以将这种模式的操作看作是一次无损的查找和替换。
    </li>
    <li>
      <h3>插值选择器的Extend</h3>
      <p>
        extend不能匹配带有变量的选择器。如果选择器带有变量，extend会无视他。
        这是一个尚待解决的问题。但是extend可以附加在带有变量的选择器上。
      </p>
      <pre><code class="language-less">@variable: .bucket;
@{variable} { // interpolated selector
  color: blue;
}
.some-class:extend(.bucket) {} // 不能匹配到变量插值的选择器

.bucket {
  color: blue;
}
.some-class:extend(@{variable}) {} // 也不能匹配到
@variable: .bucket;</code></pre>上例中这两种情况都不能匹配到extend。
<pre><code class="language-less">.bucket {
  color: blue;
}
@{variable}:extend(.bucket) {}
@variable: .selector;</code></pre>编译为: <pre><code class="language-css">.bucket, .selector {
  color: blue;
}</code></pre>
    </li>
    <li>
      <h3>作用域</h3>
      <p>
        媒体查询下的extend只能匹配到声明块内的选择器:
      </p>
      <pre><code class="language-less">@media print {
  .screenClass:extend(.selector) {} // extend inside media
  .selector { // this will be matched - it is in the same media
    color: black;
  }
}
.selector { // ruleset on top of style sheet - extend ignores it
  color: red;
}
@media screen {
  .selector {  // ruleset inside another media - extend ignores it
    color: blue;
  }
}</code></pre>编译为: <pre><code class="language-css">@media print {
  .selector,
  .screenClass { /*  ruleset inside the same media was extended */
    color: black;
  }
}
.selector { /* ruleset on top of style sheet was ignored */
  color: red;
}
@media screen {
  .selector { /* ruleset inside another media was ignored */
    color: blue;
  }
}</code></pre>写在一个媒体块中的extend不能匹配下一级媒体块中定义的选择器:
<pre><code class="language-less">@media screen {
  .screenClass:extend(.selector) {} // extend inside media
  @media (min-width: 1023px) {
    .selector {  // ruleset inside nested media - extend ignores it
      color: blue;
    }
  }
}</code></pre>编译为: <pre><code class="language-css">@media screen and (min-width: 1023px) {
  .selector { /* ruleset inside another nested media was ignored */
    color: blue;
  }
}</code></pre>顶级的extend可以匹配任何选择器，包阔嵌套在媒体块中的选择器:
<pre><code class="language-less">@media screen {
  .selector {  /* ruleset inside nested media - top level extend works */
    color: blue;
  }
  @media (min-width: 1023px) {
    .selector {  /* ruleset inside nested media - top level extend works */
      color: blue;
    }
  }
}
.topLevel:extend(.selector) {} /* top level extend matches everything */</code></pre>
编译为: <pre><code class="language-css">@media screen {
  .selector,
  .topLevel { /* ruleset inside media was extended */
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel { /* ruleset inside nested media was extended */
    color: blue;
  }
}</code></pre>
    </li>
    <li>
      <h3>重复检查</h3>
      <p>
        没有重复检测功能
      </p>
      <pre><code class="language-less">.alert-info,
.widget {
  /* declarations */
}
.alert:extend(.alert-info, .widget) {}</code></pre>编译为: <pre><code class="language-css">.alert-info,
.widget,
.alert,
.alert {
  /* declarations */
}</code></pre>
    </li>
    <li>
      <h3>经典案例</h3>
      <ul>
        <li>
          <h4>避免添加基础类</h4>
          <p>
            比如，有一个类：
            <pre><code class="language-css">.animal {
  background-color: black;
  color: white;
}</code></pre>
            想要创建一个animal子类型，修改背景色。有两个选择，首先改变HTML
<pre><code class="language-markup">&lt;a class="animal bear"&gt;Bear&lt;/a&gt;</code>
<code class="language-css">/* .css */
.animal {
  background-color: black;
  color: white;
}
.bear {
  background-color: brown;
}</code></pre>或者是简化HTML使用less的extend: <pre><code class="language-markup">&lt;a class="bear"&gt;Bear&lt;/a&gt;</code>
<code class="language-less">//.less
.animal {
  background-color: black;
  color: white;
}
.bear {
  &amp;:extend(.animal);
  background-color: brown;
}</code></pre>
          </p>
        </li>
        <li>
          <h4>精简css</h4>
          <p>
            mixin复制所有属性到选择器下生成新的规则列表，会引起不必要的重复。
            可以使用extend代替mixin，将选择器移动到规则上，从而只生成必要的css。
          </p>
          <pre><code class="language-less">//- with mixin:
.my-inline-block() {
    display: inline-block;
  font-size: 0;
}
.thing1 {
  .my-inline-block;
}
.thing2 {
  .my-inline-block;
}</code></pre>编译为: <pre><code class="language-css">.thing1 {
  display: inline-block;
  font-size: 0;
}
.thing2 {
  display: inline-block;
  font-size: 0;
}</code></pre><pre><code class="language-less">//- with extends:
.my-inline-block {
  display: inline-block;
  font-size: 0;
}
.thing1 {
  &amp;:extend(.my-inline-block);
}
.thing2 {
  &amp;:extend(.my-inline-block);
}</code></pre>编译为: <pre><code class="language-css">.my-inline-block,
.thing1,
.thing2 {
  display: inline-block;
  font-size: 0;
}</code></pre>
        </li>
        <li>
          <h4>Combining Styles / A More Advanced Mixin</h4>
          <p>
            另一个案例是mixin的替代，因为mixin只能用在简单的选择器上，
            如果有两个不同的html区块，需要引用相同的样式，可以使用extend关联两个区块。
          </p>
          <pre><code class="language-less">li.list > a {
  // list styles
}
button.list-style {
  &amp;:extend(li.list > a); // use the same list styles
}</code></pre>
        </li>
      </ul>
    </li>
  </ol>
</div>
