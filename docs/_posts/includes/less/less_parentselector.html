<div class="chapter-item">
  <a name="父选择器"></a>
  <h2 class="chapter-title">父选择器&amp;</h2>
  <article>
    <p>
      &amp;符号代表嵌套规则上的父选择器，在处理现存选择器的伪类或修改类的时候很有用
    </p>
    <pre><code class="language-less">a {
  color: blue;
  &amp;:hover {
    color: green;
  }
}</code></pre>编译为: <pre><code class="language-css">a {
  color: blue;
}

a:hover {
  color: green;
}</code></pre>注意咯，如果没有&amp;符号，将会输出<code class="language-css">a :hover</code>
    (<code class="language-css">a:hover</code>是不一样的)。
    <ol>
      <li>
        <h3>重复选择器</h3>
        <pre><code class="language-less">.button {
  &amp;-ok {
    background-image: url("ok.png");
  }
  &amp;-cancel {
    background-image: url("cancel.png");
  }

  &amp;-custom {
    background-image: url("custom.png");
  }
}</code></pre>编译为: <pre><code class="language-css">.button-ok {
  background-image: url("ok.png");
}
.button-cancel {
  background-image: url("cancel.png");
}
.button-custom {
  background-image: url("custom.png");
}</code></pre>
    </li>
    <li>
      <h3>多个&amp;</h3>
      <pre><code class="language-less">.link {
  &amp; + &amp; {
    color: red;
  }

  &amp; &amp; {
    color: green;
  }

  &amp;&amp; {
    color: blue;
  }

  &amp;, &amp;ish {
    color: cyan;
  }
}</code></pre>编译为: <pre><code class="language-css">.link + .link {
  color: red;
}
.link .link {
  color: green;
}
.link.link {
  color: blue;
}
.link, .linkish {
  color: cyan;
}</code></pre>注意&amp;会呈现所有当前的父选择器，而不是最近的父选择器: <pre><code class="language-less">.grand {
  .parent {
    &amp; > &amp; {
      color: red;
    }

    &amp; &amp; {
      color: green;
    }

    &amp;&amp; {
      color: blue;
    }

    &amp;, &amp;ish {
      color: cyan;
    }
  }
}</code></pre>编译为: <pre><code class="language-css">.grand .parent > .grand .parent {
  color: red;
}
.grand .parent .grand .parent {
  color: green;
}
.grand .parent.grand .parent {
  color: blue;
}
.grand .parent,
.grand .parentish {
  color: cyan;
}</code></pre>
    </li>
    <li>
      <h3>改变选择器顺序</h3>
      <p>
        通过在&amp;前面添加前缀选择器，可以改变选择器顺序。
        For example, when using Modernizr, you might want to specify different rules
        based on supported features:
      </p>
      <pre><code class="language-less">.header {
  .menu {
    border-radius: 5px;
    .no-borderradius &amp; {
      background-image: url('images/button-background.png');
    }
  }
}</code></pre>编译为: <pre><code class="language-css">.header .menu {
  border-radius: 5px;
}
.no-borderradius .header .menu {
  background-image: url('images/button-background.png');
}</code></pre>
    </li>
    <li>
      <h3>组合扩展</h3>
      <p>
        &smp;可用于生成用逗号分开的选择器列表中每一种可能的选择器组合
      </p>
      <pre><code class="language-less">p, a, ul, li {
  border-top: 2px dotted #366;
  &amp; + &amp; {
    border-top: 0;
  }
}</code></pre>这里可编译生成16种组合结果: <pre><code class="language-css">p,
a,
ul,
li {
  border-top: 2px dotted #366;
}
p + p,
p + a,
p + ul,
p + li,
a + p,
a + a,
a + ul,
a + li,
ul + p,
ul + a,
ul + ul,
ul + li,
li + p,
li + a,
li + ul,
li + li {
  border-top: 0;
}</code></pre>
      </li>
    </ol>
  </article>
</div>
