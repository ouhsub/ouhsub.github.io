<div class="chapter-item">
  <a name="高阶定制"></a>
  <h2 class="chapter-title">高阶定制</h2>
  <article>
    <ul>

      <li>
        <h3>永久链接</h3>
        <p>
          Jekyll支持以灵活的方式管理网站的链接，
          可以通过配置文件或YAML头信息为每篇文章设置永久链接。
          永久链接的模板用 以冒号为前缀的关键词 标记动态内容。
          可以随心所欲地选择链接的模板，既可以使用内置模板，也可以自定义模板。
          默认格式为date: /:categories/:year/:month/:day/:title.html。
        </p>
        <ol>
          {% for link in site.data.jekyll.permalinks %}
          <li>
            <h4>{{ link.name }}</h4>
            <ul>
              {% for data in link.data %}
                <li>
                  <strong>{{ data.name }}</strong>
                  <p>
                    {{ data.desc }}
                  </p>
                </li>
              {% endfor %}
            </ul>
          </li>
          {% endfor %}
          <li>
            <h4>独立页面和集合</h4>
            <p>永久链接配置指定post的永久链接模式。独立页面和集合拥有各自的默认永久链接模式:
              独立页面的默认模式是 /:path/:basename; 而集合的默认模式则是 /:collection/:path。
            </p>
            <p>
              这些样式会根据post永久链接设置做出相应的修改。
              比如，一个pretty模式的永久链接，末尾带有一个斜线，会让独立页面的永久链接也带上斜线:
              /:path/:basename/。一个date模式的永久链接，末尾带着文件扩展名，
              这让独立页面的永久链接也带上一个文件扩展名: /:path/:basename:output_ext。
              自定义永久链接模板的效果也是一样的。
            </p>
            <p>
              独立页面或集合文档的永久链接能够在page或document的YAML头信息中被重写。
              此外，一个给定集合的永久链接能够在集合的配置项中自定义。
            </p>
          </li>
          <li>
            <h4>不带扩展名的永久链接</h4>
            <p>
              Jekyll支持不带斜线或文件扩展名的永久链接，但是这需要服务器的支持。
              当使用无扩展的永久链接，输出文件仍然带有相应的扩展名，
              所以服务器必须能够将不带扩展的链接请求映射到带有扩展名的文件上。
              Github Pages和Jekyll的预览服务器都可以处理这种请求，而不需要任何附加的操作。
            </p>
          </li>
        </ol>
      </li>
      <li>
        <h3>分页</h3>
        <p>
          对于大多数网站，当文章越来越多，就会有分页显示文章列表的需求。
          Jekyll已经自建分页功能，只需要根据约定放置文件即可。
        </p>
        <p>
          对于Jekyll3,需要使用jekyll-paginate插件实现分页，对于Jekyll2，分页功能是个标准配备。
        </p>
        <p>
          分页功能只支持 HTML 文件。Jekyll 的分页功能不支持 Markdown 或 Textile 文件，
          而是只支持 HTML 文件。分页器从index.html这个文件中调用才能工作，可以放在子目录中，
          需要通过<code class="language-yaml">pagination_path</code>配置项进行设置。
        </p>
        <ol>
          <li>
            <h4>启用分页器</h4>
            <p>
              要启用分页功能，需要在_config.yml文件中指定每页展示多少条文章:
              <code class="language-yaml">paginate: 5</code>。
              也可以指定分页的目的地:
              <code class="language-yaml">paginate_path: "/blog/page:num/"</code>。
              <code class="language-bash">blog/index.html</code>将读取这个设置，
              把它传给每个分页页面，然后从第2页开始输出到 blog/page:num ， :num 是页码, 从2开始。
              如果一个站点有12篇文章，并且设定<code class="language-yaml">paginate: 5</code>，
              那么，Jekyll将创建三个文件: <code class="language-bash">blog/index.html</code>(写入头5篇文章的列表)，
              <code class="language-bash">blog/page2/index.html</code>(写入6-10条文章列表)，
              <code class="language-bash">blog/page3/index.html</code>(写入最后两条文章的列表)。
            </p>
            <p>
              在博客页中设置永久链接会破坏分页器，不能设置永久链接。
            </p>
          </li>
          <li>
            <h4>可用的Liquid属性</h4>
            <ul>
              {% for data in site.data.jekyll.pagination %}
              <li>
                <strong>{{ data.name }}</strong>
                <p>
                  {{ data.desc }}
                </p>
              </li>
              {% endfor %}
            </ul>
            <p>
              不支持对tags或categories分页。<br>
              分页功能遍历文章列表(除非YAML头信息中标志出hidden: true)并计算出分页结果。
              不支持对“标签”和“类别”分页。不能包含任何集合文档，因为相对于post来说它是受限制的。
            </p>
          </li>
          <li>
            <h4>渲染带分页功能的文章</h4>
            <p>
              接下来要做的就是使用分页器的变量将post列表显示出来了。
              可以将分页器放置在站点的主页面上，这里是在一个HTML文件中渲染分页器的例子:
              <pre><code class=“language-yaml”>---
layout: default
title: My Blog
---</code><code class="language-markup">
{% raw %}
&lt;!-- This loops through the paginated posts --&gt;
{% for post in paginator.posts %}
  &lt;h1&gt;&lt;a href="{{ post.url }}"&gt;{{ post.title }}&lt;/a&gt;&lt;/h1&gt;
  &lt;p class="author"&gt;
    &lt;span class="date"&gt;{{ post.date }}&lt;/span&gt;
  &lt;/p&gt;
  &lt;div class="content"&gt;
    {{ post.content }}
  &lt;/div&gt;
{% endfor %}

&lt;!-- Pagination links --&gt;
&lt;div class="pagination"&gt;
  {% if paginator.previous_page %}
    &lt;a href="{{ paginator.previous_page_path }}" class="previous"&gt;Previous&lt;/a&gt;
  {% else %}
    &lt;span class="previous"&gt;Previous&lt;/span&gt;
  {% endif %}
    &lt;span class="page_number "&gt;Page: {{ paginator.page }} of {{ paginator.total_pages }}&lt;/span&gt;
  {% if paginator.next_page %}
    &lt;a href="{{ paginator.next_page_path }}" class="next"&gt;Next&lt;/a&gt;
  {% else %}
    &lt;span class="next "&gt;Next&lt;/span&gt;
  {% endif %}{% endraw %}
&lt;/div&gt;</code></pre>
            </p>
            <p>
              注意首尾页 <br>
              Jekyll没有生成‘page1’文件夹，所以上边的代码有问题，下边的代码解决了这个问题。
            </p>
            <p>
              下边的HTML片段是第一页，它为除了当前页外的每个页面生成了链接。
              <pre><code class="language-markup">{% raw %}{% if paginator.total_pages &gt; 1 %}
  &lt;div class="pagination"&gt;
  {% if paginator.previous_page %}
    &lt;a href="{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}"&gt;&laquo; Prev&lt;/a&gt;
  {% else %}
    &lt;span&gt;&laquo; Prev&lt;/span&gt;
  {% endif %}

  {% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &lt;em&gt;{{ page }}&lt;/em&gt;
    {% elsif page == 1 %}
      &lt;a href="{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}"&gt;{{ page }}&lt;/a&gt;
    {% else %}
      &lt;a href="{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}"&gt;{{ page }}&lt;/a&gt;
    {% endif %}
  {% endfor %}

  {% if paginator.next_page %}
    &lt;a href="{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}"&gt;Next &raquo;&lt;/a&gt;
  {% else %}
    &lt;span&gt;Next &raquo;&lt;/span&gt;
  {% endif %}
  &lt;/div&gt;
{% endif %}{% endraw %}</code></pre>
            </p>
          </li>
        </ol>
      </li>
      <li>
        <h3>插件</h3>
        ruby的，玩毛。。。
      </li>
      <li>
        <h3>主题</h3>
        <p>
          Jekyll有一个主题扩展系统，提供由社区维护的模板样式，可以用来定制站点样式表现。
          Jekyll将模板，组件及样式表打包进站点，可以对其进行覆写。
        </p>
        <ol>
          <li>
            <h4>下载主题</h4>
            <ul>
              <li>
                要下载主题模板，首先将主题添加到站点的Gemfile中:
                <code class="language-bash">gem 'my-awesome-jekyll-theme'</code>
              </li>
              <li>
                将变化保存到<code class="language-bash">Gemfile</code>文件
              </li>
              <li>
                运行命令下载这个主题<code class="language-bash">bundle install</code>
              </li>
              <li>
                激活主题:
                <pre><code class="language-yaml">#_config.yml
theme: my-awesome-jekyll-theme</code></pre>
                </li>
              </ul>
              <p>
                可以在Gemfile文件中列出多个主题，但是只能在站点的配置文件中激活一个主题模板。
              </p>
          </li>
          <li>
            <h4>重写主题默认设置</h4>
            <p>
              Jekyll主题设置了默认的模板，组件及样式，可以使用站点内容重写这些设置。
              例如主题有一个page模板，可以通过在_layouts文件夹下
              创建自定义的page模板来覆写默认的page模板。Jekyll在使用默认设置前会先查询站点的内容，
              任何文件请求都是按这个顺序来处理的:
            </p>
            <ul>
              <li>/assets</li>
              <li>/_layouts</li>
              <li>/_includes</li>
              <li>/_sass</li>
            </ul>
            <p>
              更多信息可查阅主题的文档和源文件仓库。
            </p>
            <p>
              要定位主题文件在本地的位置，可以运行命令<code class="language-bash">bundle show</code>
              紧跟着主题gem的名称，如: <code class="language-bash">bundle show minima</code>。
              然后根据返回的路径拷贝想要覆写的文件就可以了。
            </p>
          </li>
          <li>
            <h4>创建主题</h4>
            <p>
              Jekyll主题作为Ruby gems分布存储，Jekyll会帮助创建主题的脚手架。使用这个命令就可以啦:
            </p>
            <code class="language-bash">jekyll new-theme &lt;theme-name&gt;</code>
            <pre><code class="language-bash">$ jekyll new-theme my-awesome-theme
    create /path/to/my-awesome-theme/_layouts
    create /path/to/my-awesome-theme/_includes
    create /path/to/my-awesome-theme/_sass
    create /path/to/my-awesome-theme/_layouts/page.html
    create /path/to/my-awesome-theme/_layouts/post.html
    create /path/to/my-awesome-theme/_layouts/default.html
    create /path/to/my-awesome-theme/Gemfile
    create /path/to/my-awesome-theme/my-awesome-theme.gemspec
    create /path/to/my-awesome-theme/README.md
    create /path/to/my-awesome-theme/LICENSE.txt
    initialize /path/to/my-awesome-theme/.git
    create /path/to/my-awesome-theme/.gitignore
Your new Jekyll theme, my-awesome-theme,
is ready for you in /path/to/my-awesome-theme!
For help getting started, read /path/to/my-awesome-theme/README.md.</code></pre>
            <p>
              添加模板文件到相应的文件夹，按需完成 .gemspec文件和README文件。
            </p>
            <ol>
              <li>
                <strong>模板和组件</strong><br>
                <p>
                  模板和组件像任何Jekyll站点内的模板和组件一样工作。将组件放在主题的/_layouts文件夹下，
                  将组件放在主题的/_includes文件夹下。
                </p>
                <p>
                  例如，主题中有一个/_layouts/page.html文件，并且一个独立页面中有
                  <code class="language-yaml">layout: page</code>的头文件信息。
                  Jekyll将首先进入站点的/_layouts文件夹下寻找page模板，如果不存在的话再寻找主题的page模板。
                </p>
              </li>
              <li>
                <strong>Assets</strong><br>
                <p>
                  /assets文件夹下的所有文件都将被复制到用户的站点，
                  除非用户文件夹下存在相同相对路径的相同文件。
                  可以在这里存放任意类型的文件咯: SCSS文件、图片、web字体等。
                  这些文件的表现跟Jekyll中的页面和静态文件表现是一样的:
                  如果文件顶部存在YAML头信息，那么它将被渲染;如果不存在，那就只是复制到生成的站点中。
                  这允许主题创建者创建一个默认的/assets/styles.scss文件，可以通过/assets/styles.css进行引用。
                </p>
                <p>
                  所有在/assets目录下的文件都将被输出到所生成站点的/assets文件夹，就像使用Jekyll一样。
                </p>
              </li>
              <li>
                <strong>Stylesheets</strong><br>
                <p>
                  主题的样式表可以哦放在主题的/_sass文件夹下。用户的样式可以通过
                  <code class="language-css">@import</code>指令导入主题样式。
                </p>
              </li>
              <li>
                <strong>主题的文档</strong><br>
                <p>
                  主题应该包含一个/README.md文件，用以向站点作者解释该如何下载和使用你的主题，
                  有什么模板和组件，需要在站点设置文件中添加什么不？
                </p>
              </li>
              <li>
                <strong>添加主题截屏</strong><br>
                <p>
                  主题是可视的，要向用户展示你的主题长什么样，可以在主题仓库下包含一个screenshot.png图片。
                  可以通过代码检索到这个文件，或者也可以放在文档中。
                </p>
              </li>
              <li>
                <strong>预览主题</strong><br>
                <p>
                  要想预览主题，可以添加样本内容，比如/index.html和page.html文件。
                  然后可以通过Jekyll的命令<code class="language-bash">jekyll server</code>
                  或<code class="language-bash">jekyll server</code>来预览主题啦。
                </p>
                <p>
                  如过是在本地预览主题，记得将/_site添加到.gitignore文件。
                </p>
              </li>
              <li>
                <strong>发布主题</strong><br>
                <p>
                  主题是通过RubyGems.org发布的，需要先有一个RubyGems账户。
                </p>
                <p>
                  首先，运行命令打包主题: <code class="language-bash">gem build &lt;theme-name&gt;.gemspec</code>。
                  然后，通过这个命令: <code class="language-bash">gem push &lt;theme-name&gt;-*.gem</code>将主题包上传到RubyGems服务器。
                  要发布主题的新版本，要发布新的主题版本，只要更新gemspec文件中的版本号，
                  然后再重新提交一下就可以啦。推荐遵循<a href="https://http://semver.org/" target="_blank">版本语义化</a>
                  的规则。
                </p>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ul>
  </article>
</div>
